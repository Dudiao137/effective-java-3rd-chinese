# Summary


* [Chapter 2. Creating and Destroying Objects](./Chapter2.md)

    - [01. 考虑使用静态工厂方法替代构造方法](./01.考虑使用静态工厂方法替代构造方法.md)
    - [02. 当构造方法参数过多时使用builder模式](./02.当构造方法参数过多时使用builder模式.md)
    - [03. 使用私有构造方法或枚类实现Singleton属性](./03.使用私有构造方法或枚类实现Singleton属性.md)
    - [04. 使用私有构造方法执行非实例化](./04.使用私有构造方法执行非实例化.md)
    - [05. 依赖注入优于硬连接资源(hardwiring resources)](./05.依赖注入优于硬连接资源(hardwiringresources).md)
    - [06. 避免创建不必要的对象](./06.避免创建不必要的对象.md)
    - [07. 消除过期的对象引用](./07.消除过期的对象引用.md)
    - [08. 避免使用Finalizer和Cleaner机制](./08.避免使用Finalizer和Cleaner机制.md)

* [Chapter 3. Methods Common to All Objects](./Chapter3.md)

    - [09. 使用try-with-resources语句替代try-finally语句](./09.使用try-with-resources语句替代try-finally语句.md)
    - [10. 重写equals方法时遵守通用约定](./10.重写equals方法时遵守通用约定.md)
    - [11. 重写equals方法时同时也要重写hashcode方法](./11.重写equals方法时同时也要重写hashcode方法.md)
    - [12. 始终重写 toString 方法](./12.始终重写toString方法.md)
    - [13. 谨慎地重写 clone 方法](./13.谨慎地重写clone方法.md)
    - [14. 考虑实现Comparable接口](./14.考虑实现Comparable接口.md)

* [Chapter 4. Classes and Interfaces](./Chapter4.md)

    - [15. 使类和成员的可访问性最小化](./15.使类和成员的可访问性最小化.md)
    - [16. 在公共类中使用访问方法而不是公共属性](./16.在公共类中使用访问方法而不是公共属性.md)
    - [17. 最小化可变性](./17.最小化可变性.md)
    - [18. 组合优于继承](./18.组合优于继承.md)
    - [19. 要么设计继承并提供文档说明，要么禁用继承](./19.要么设计继承并提供文档说明，要么禁用继承.md)
    - [20. 接口优于抽象类](./20.接口优于抽象类.md)
    - [21. 为后代设计接口](./21.为后代设计接口.md)
    - [22. 接口仅用来定义类型](./22.接口仅用来定义类型.md)
    - [23. 类层次结构优于标签类](./23.类层次结构优于标签类.md)
    - [24. 支持使用静态成员类而不是非静态类](./24.支持使用静态成员类而不是非静态类.md)
    - [25. 将源文件限制为单个顶级类](./25.将源文件限制为单个顶级类.md)

* [Chapter 5. Generics](./Chapter5.md)

    - [26. 不要使用原始类型](./26.不要使用原始类型.md)
    - [27. 消除非检查警告](./27.消除非检查警告.md)
    - [28. 列表优于数组](./28.列表优于数组.md)
    - [29. 优先考虑泛型](./29.优先考虑泛型.md)
    - [30. 优先使用泛型方法](./30.优先使用泛型方法.md)
    - [31. 使用限定通配符来增加API的灵活性](./31.使用限定通配符来增加API的灵活性.md)
    - [32. 合理地结合泛型和可变参数](./32.合理地结合泛型和可变参数.md)
    - [33. 优先考虑类型安全的异构容器](./33.优先考虑类型安全的异构容器.md)

* [Chapter 6. Enums and Annotations](./Chapter6.md)

    - [34. 使用枚举类型替代整型常量](./34.使用枚举类型替代整型常量.md)
    - [35. 使用实例属性替代序数](./35.使用实例属性替代序数.md)
    - [36. 使用EnumSet替代位属性](./36.使用EnumSet替代位属性.md)
    - [37. 使用EnumMap替代序数索引](./37.使用EnumMap替代序数索引.md)
    - [38. 使用接口模拟可扩展的枚举](./38.使用接口模拟可扩展的枚举.md)
    - [39. 注解优于命名模式](./39.注解优于命名模式.md)
    - [40. 始终使用Override注解](./40.始终使用Override注解.md)
    - [41. 使用标记接口定义类型](./41.使用标记接口定义类型.md)

* [Chapter 7. Lambdas and Streams](./Chapter7.md)

    - [42. lambda表达式优于匿名类](./42.lambda表达式优于匿名类.md)
    - [43. 方法引用优于lambda表达式](./43.方法引用优于lambda表达式.md)
    - [44. 优先使用标准的函数式接口](./44.优先使用标准的函数式接口.md)
    - [45. 明智审慎地使用Stream](./45.明智审慎地使用Stream.md)
    - [46. 优先考虑流中无副作用的函数](./46.优先考虑流中无副作用的函数.md)
    - [47. 优先使用Collection而不是Stream来作为方法的返回类型](./47.优先使用Collection而不是Stream来作为方法的返回类型.md)
    - [48. 谨慎使用流并行](./48.谨慎使用流并行.md)

* [Chapter 8. Methods](./Chapter8.md)

    - [49. 检查参数有效性](./49.检查参数有效性.md)
    - [50. 必要时进行防御性拷贝](./50.必要时进行防御性拷贝.md)
    - [51. 仔细设计方法签名](./51.仔细设计方法签名.md)
    - [52. 明智审慎地使用重载](./52.明智审慎地使用重载.md)
    - [53. 明智审慎地使用可变参数](./53.明智审慎地使用可变参数.md)
    - [54. 返回空的数组或集合，不要返回 null](./54.返回空的数组或集合，不要返回null.md)
    - [55. 明智审慎地返回 Optional](./55.明智审慎地返回Optional.md)
    - [56. 为所有已公开的 API 元素编写文档注释](./56.为所有已公开的API元素编写文档注释.md)

* [Chapter 9. General Programming](./Chapter9.md)

    - [57. 最小化局部变量的作用域](./57.最小化局部变量的作用域.md)
    - [58. for-each 循环优于传统 for 循环](./58.for-each循环优于传统for循环.md)
    - [59. 了解并使用库](./59.了解并使用库.md)
    - [60. 若需要精确答案就应避免使用 float 和 double 类型](./60.若需要精确答案就应避免使用float和double类型.md)
    - [61. 基本数据类型优于包装类](./61.基本数据类型优于包装类.md)
    - [62. 当使用其他类型更合适时应避免使用字符串](./62.当使用其他类型更合适时应避免使用字符串.md)
    - [63. 当心字符串连接引起的性能问题](./63.当心字符串连接引起的性能问题.md)
    - [64. 通过接口引用对象](./64.通过接口引用对象.md)
    - [65. 接口优于反射](./65.接口优于反射.md)
    - [66. 明智审慎地本地方法](./66.明智审慎地本地方法.md)
    - [67. 明智审慎地进行优化](./67.明智审慎地进行优化.md)
    - [68. 遵守被广泛认可的命名约定](./68.遵守被广泛认可的命名约定.md)

* [Chapter 10. Exceptions](./Chapter10.md)

    - [69. 只针对异常的情况下才使用异常](./69.只针对异常的情况下才使用异常.md)
    - [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](./70.对可恢复的情况使用受检异常，对编程错误使用运行时异常.md)
    - [71. 避免不必要的使用受检异常](./71.避免不必要的使用受检异常.md)
    - [72. 优先使用标准的异常](./72.优先使用标准的异常.md)
    - [73. 抛出与抽象对应的异常](./73.抛出与抽象对应的异常.md)
    - [74. 每个方法抛出的异常都需要创建文档](./74.每个方法抛出的异常都需要创建文档.md)
    - [75. 在细节消息中包含失败一捕获信息](./75.在细节消息中包含失败一捕获信息.md)
    - [76. 保持失败原子性](./76.保持失败原子性.md)
    - [77. 不要忽略异常](./77.不要忽略异常.md)

* [Chapter 11. Concurrency](./Chapter11.md)

    - [78. 同步访问共享的可变数据](./78.同步访问共享的可变数据.md)
    - [79. 避免过度同步](./79.避免过度同步.md)
    - [80. executor 、task 和 stream 优先于线程](./80.executor、task和stream优先于线程.md)
    - [81. 并发工具优于 wait 和 notify](./81.并发工具优于wait和notify.md)
    - [82. 文档应包含线程安全属性](./82.文档应包含线程安全属性.md)
    - [83. 明智审慎的使用延迟初始化](./83.明智审慎的使用延迟初始化.md)
    - [84. 不要依赖线程调度器](./84.不要依赖线程调度器.md)

* [Chapter 12. Serialization](./Chapter12.md)

    - [85. 优先选择 Java 序列化的替代方案](./85.优先选择Java序列化的替代方案.md)
    - [86. 非常谨慎地实现 Serializable](./86.非常谨慎地实现Serializable.md)
    - [87. 考虑使用自定义的序列化形式](./87.考虑使用自定义的序列化形式.md)
    - [88. 保护性的编写 readObject 方法](./88.保护性的编写readObject方法.md)
    - [89. 对于实例控制，枚举类型优于 readResolve](./89.对于实例控制，枚举类型优于readResolve.md)
    - [90. 考虑用序列化代理代替序列化实例](./90.考虑用序列化代理代替序列化实例.md)
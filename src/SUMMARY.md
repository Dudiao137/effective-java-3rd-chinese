# Summary


- [Chapter 2. Creating and Destroying Objects](Chapter2.md)

    - [01. 考虑使用静态工厂方法替代构造方法](01.md)
    - [02. 当构造方法参数过多时使用builder模式](02.md)
    - [03. 使用私有构造方法或枚类实现Singleton属性](03.md)
    - [04. 使用私有构造方法执行非实例化](04.md)
    - [05. 依赖注入优于硬连接资源(hardwiring resources)](05.md)
    - [06. 避免创建不必要的对象](06.md)
    - [07. 消除过期的对象引用](07.md)
    - [08. 避免使用Finalizer和Cleaner机制](08.md)

- [Chapter 3. Methods Common to All Objects](Chapter3.md)

    - [09. 使用try-with-resources语句替代try-finally语句](09.md)
    - [10. 重写equals方法时遵守通用约定](10.md)
    - [11. 重写equals方法时同时也要重写hashcode方法](11.md)
    - [12. 始终重写 toString 方法](12.md)
    - [13. 谨慎地重写 clone 方法](13.md)
    - [14. 考虑实现Comparable接口](14.md)

- [Chapter 4. Classes and Interfaces](Chapter4.md)

    - [15. 使类和成员的可访问性最小化](15.md)
    - [16. 在公共类中使用访问方法而不是公共属性](16.md)
    - [17. 最小化可变性](17.md)
    - [18. 组合优于继承](18.md)
    - [19. 要么设计继承并提供文档说明，要么禁用继承](19.md)
    - [20. 接口优于抽象类](20.md)
    - [21. 为后代设计接口](21.md)
    - [22. 接口仅用来定义类型](22.md)
    - [23. 类层次结构优于标签类](23.md)
    - [24. 支持使用静态成员类而不是非静态类](24.md)
    - [25. 将源文件限制为单个顶级类](25.md)

- [Chapter 5. Generics](Chapter5.md)

    - [26. 不要使用原始类型](26.md)
    - [27. 消除非检查警告](27.md)
    - [28. 列表优于数组](28.md)
    - [29. 优先考虑泛型](29.md)
    - [30. 优先使用泛型方法](30.md)
    - [31. 使用限定通配符来增加API的灵活性](31.md)
    - [32. 合理地结合泛型和可变参数](32.md)
    - [33. 优先考虑类型安全的异构容器](33.md)

- [Chapter 6. Enums and Annotations](Chapter6.md)

    - [34. 使用枚举类型替代整型常量](34.md)
    - [35. 使用实例属性替代序数](35.md)
    - [36. 使用EnumSet替代位属性](36.md)
    - [37. 使用EnumMap替代序数索引](37.md)
    - [38. 使用接口模拟可扩展的枚举](38.md)
    - [39. 注解优于命名模式](39.md)
    - [40. 始终使用Override注解](40.md)
    - [41. 使用标记接口定义类型](41.md)

- [Chapter 7. Lambdas and Streams](Chapter7.md)

    - [42. lambda表达式优于匿名类](42.md)
    - [43. 方法引用优于lambda表达式](43.md)
    - [44. 优先使用标准的函数式接口](44.md)
    - [45. 明智审慎地使用Stream](45.md)
    - [46. 优先考虑流中无副作用的函数](46.md)
    - [47. 优先使用Collection而不是Stream来作为方法的返回类型](47.md)
    - [48. 谨慎使用流并行](48.md)

- [Chapter 8. Methods](Chapter8.md)

    - [49. 检查参数有效性](49.md)
    - [50. 必要时进行防御性拷贝](50.md)
    - [51. 仔细设计方法签名](51.md)
    - [52. 明智审慎地使用重载](52.md)
    - [53. 明智审慎地使用可变参数](53.md)
    - [54. 返回空的数组或集合，不要返回 null](54.md)
    - [55. 明智审慎地返回 Optional](55.md)
    - [56. 为所有已公开的 API 元素编写文档注释](56.md)

- [Chapter 9. General Programming](Chapter9.md)

    - [57. 最小化局部变量的作用域](57.md)
    - [58. for-each 循环优于传统 for 循环](58.md)
    - [59. 了解并使用库](59.md)
    - [60. 若需要精确答案就应避免使用 float 和 double 类型](60.md)
    - [61. 基本数据类型优于包装类](61.md)
    - [62. 当使用其他类型更合适时应避免使用字符串](62.md)
    - [63. 当心字符串连接引起的性能问题](63.md)
    - [64. 通过接口引用对象](64.md)
    - [65. 接口优于反射](65.md)
    - [66. 明智审慎地本地方法](66.md)
    - [67. 明智审慎地进行优化](67.md)
    - [68. 遵守被广泛认可的命名约定](68.md)

- [Chapter 10. Exceptions](Chapter10.md)

    - [69. 只针对异常的情况下才使用异常](69.md)
    - [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](70.md)
    - [71. 避免不必要的使用受检异常](71.md)
    - [72. 优先使用标准的异常](72.md)
    - [73. 抛出与抽象对应的异常](73.md)
    - [74. 每个方法抛出的异常都需要创建文档](74.md)
    - [75. 在细节消息中包含失败一捕获信息](75.md)
    - [76. 保持失败原子性](76.md)
    - [77. 不要忽略异常](77.md)

- [Chapter 11. Concurrency](Chapter11.md)

    - [78. 同步访问共享的可变数据](78.md)
    - [79. 避免过度同步](79.md)
    - [80. executor 、task 和 stream 优先于线程](80.md)
    - [81. 并发工具优于 wait 和 notify](81.md)
    - [82. 文档应包含线程安全属性](82.md)
    - [83. 明智审慎的使用延迟初始化](83.md)
    - [84. 不要依赖线程调度器](84.md)

- [Chapter 12. Serialization](Chapter12.md)

    - [85. 优先选择 Java 序列化的替代方案](85.md)
    - [86. 非常谨慎地实现 Serializable](86.md)
    - [87. 考虑使用自定义的序列化形式](87.md)
    - [88. 保护性的编写 readObject 方法](88.md)
    - [89. 对于实例控制，枚举类型优于 readResolve](89.md)
    - [90. 考虑用序列化代理代替序列化实例](90.md)